# Распределенная база данных изображений
## Архитектура

![architecture](http://iostd.ru/static/architecture.svg)

Архитектура всей системы разделяется на два отдельных уровня: уровень приложения и уровень СУБД. Модули `Приложение` и `Клиент СУБД` уровня приложения связаны между собой программным интерфейсом (API) и в конечном итоге образуют единое приложение. Модуль `Клиент СУБД` общяется с узлами БД посредством программного веб-интерфейса (WebAPI) через протокол HTTP. В свою очередь модули `Узел БД` и `Хранилище` связаны между собой программным интерфейсом.

Таким образом, для создания всей системы, нужно реализовать следующие модули:
* Приложение
* Библиотека клиента СУБД
* Узел БД
* Хранилище

## Приложение

Приложение должно, используя программный интерфейс библиотеки клиента СУБД, реализовывать следующий функционал:

* Загрузкить изображение в СУБД.
* Получить изображение из СУБД по ключу.
* Удалить изображение из СУБД по ключу.

## Библиотека клиента СУБД

Библиотека клиента СУБД должна реализоввывать абстрактную прослойку между программным интерфейсом приложения и программным веб-интерфейсом узлов БД.

Таким образом, со стороны приложения должен быть примерно следующий программный интерфейс:

```
public interface ImageDatabase {

    public void put(String key, Image image) throws ImageDatabaseException;

    public Image get(String key) throws ImageDatabaseException;

    public void remove(String key) throws ImageDatabaseException;
}
```

Поскольку неизвестно, на каком узле находится необходимое изображение, то клиенту необходимо явно указать список всех доступных узлов в сети. Т.е. в библиотеке клиента дополнительно необходимо реализовать загрузку конфигурационного файла.

При выполнении операций `put` и `get`, необходимо придумать подход получения и распределения изображений по узлам в сети. Пример:

* Случайный выбор узла
* Использование счетчика загруженности узла (кол-во выполненных операций `put`)
* Нагруженность канала (счетчик всех операциий с зависимостью по времени)

Дополнительно в библиотеке клиента можно реализовать алгоритмы оптимизации. Т.е. в место того, чтобы проверять каждый узел на наличие того или иного изображения, можно реализовать некий кэш. В этом кэше для каждого узла будет хранится список ключей, доступных на соответствующем узле. Таким образом, кэшируя запросы к БД можно ускорить работу всей системы. Пример:

1. Приложение запрашивает изображение с ключем `а`.
2. Клиент по некоторому алгоритму получает изображение от второго узла.
3. Клиент кэширует соовтсетствие данного ключа со вторым узлом.

Таким образом, при следущих операциях `get` и `remove` с тем же ключем клиент не будет опрашивать все узлы, а по кешу узнает узел на котором находится необходимое изображение.   

## Узел БД

Серверное приложение `Узел БД`, должно реализовать абстрактную прослойку между веб-интерфейсом и программным интерфейсом хранилища.

Веб-интерфейс должен иметь три операции.

#### Получение изображения

Получение изображения по ключу производится путем создания GET запроса на `/<ключ изображения>`. Изображение передается в теле HTTP ответа. Если указанное изображение отсутствует, то генерируется ошибка `404 Not Found`.

#### Загрузка изображения

Загрузка изображения по ключу производится путем создания PUT запроса на `/<ключ изображения>`. Изображение передается в теле HTTP запроса. Если указанный ключ существет, то генерируется ошибка `400 Bad Request`.

#### Удаление изображения

Удаление изображения по ключу производится путем создания DELETE запроса на `/<ключ изображения>`. При успешном выполнении, должен генерироватся ответ `200 OK` с пустым телом. Если указанное изображение отсутствует, то генерируется ошибка `404 Not Found`.

В случае, если при выполнении какой либо операции произошла любая другая ошибка, то в качестве ответа должна генерироваться ошибка `500 Internal Server Error`.

## Хранилище

Модуль хранилища должен реализовывать непосредсвенно функцию хранения изображений в файловой системе.

#### Большой файл

Создается большой файл со всеми данными. При малых размерах этот файл полностью кэшируется в память, а при больших, осуществляется однопроходной линейный поиск по файлу. Оптимизации по желанию.

Структура данных, например, такая:
```
<ключ><размер><значение>
<ключ><размер><значение>
<ключ><размер><значение>
...
```

Добавление данных в конец файла.

#### Большой файл с журналированием

Имеется два файла: журнал и файл данных. В журнале хранится вся необходимая информация для досупа к данным в файле данных. Например, структура журнального файла такая:

```
<ключ><размер><сдвиг-в-байтах>
<ключ><размер><сдвиг-в-байтах>
<ключ><размер><сдвиг-в-байтах>
...
```

Здесь `<сдвиг-в-байтах>`, это индекс начала документа в файле с данными. Таким образом, журнал будет иметь достаточно небольшой размер, что позволит его полностью хранить в памяти.

#### Хранение документов в файловой системе
Один документ - один файл. В этом случае путь вычисляется следующим образом. Допустим, ключ документа `f8e1c82556d24f478a1d0867892079f0`, тогда путь будет следующий: `f8/e1/c8/f0`, где f0 - имя самого файла.
